import{onMounted as y,onUnmounted as T,watch as Y,nextTick as m}from"vue";import{getScrollParent as C}from"@ulu/utils/browser/dom.js";function D({sections:i,props:e,emit:h,componentElRef:I}){let r=null;function v(t){return i.value.findIndex(({element:l})=>t===l)}function O(t=null,l="down"){i.value.forEach(c=>{c!==t&&(c.active&&(c.inactiveFrom=l==="down"?"forward":"reverse",c.activeFrom=null),c.active=!1)})}function E(){let t=0,l=!0;const c=d=>{const{root:A}=r,f=A?A.scrollTop:document.documentElement.scrollTop||window.scrollY;if(e.debug&&(console.group("useScrollAnchors: onObserve"),console.log("Observer:",r),console.log("Last/Current Y:",`${t}/${f}`),console.log("Entries:",d.map(n=>({el:n.target,is:n.isIntersecting})))),l&&e.firstItemActive){e.debug&&console.log("Initial observation, respecting `firstItemActive`."),l=!1,t=f,e.debug&&console.groupEnd();return}l=!1;const s=f>t?"down":"up";t=f,e.debug&&console.log(`Scroll direction: ${s}`);const a=d.filter(n=>n.isIntersecting);if(e.debug&&console.log("Intersecting entries:",a.map(n=>n.target)),a.length>0){a.sort((u,b)=>v(u.target)-v(b.target));const n=s==="down"?a[a.length-1]:a[0];e.debug&&console.log("Chosen target entry:",n.target);const o=i.value[v(n.target)];o&&!o.active&&(e.debug&&console.log("Activating section:",o.title),m(()=>{O(o,s),o.active=!0,o.inactiveFrom=null,o.activeFrom=s==="down"?"forward":"reverse",h("section-change",{section:o,sections:i.value,active:!0})}))}else{e.debug&&console.log("No intersecting entries. Checking edge cases.");const n=i.value.find(o=>o.active);if(n){const o=d.find(u=>u.target===n.element);if(o&&!o.isIntersecting){const u=v(o.target),b=u===0,x=u===i.value.length-1;(b&&s==="up"&&!e.firstItemActive||x&&s==="down")&&(e.debug&&console.log("Deactivating section at edge:",n.title),m(()=>{O(null,s),h("section-change",{section:n,sections:i.value,active:!1})}))}}}e.debug&&console.groupEnd()};let g=null;e.observerOptions&&e.observerOptions.root?g=e.observerOptions.root:I.value&&(g=C(I.value),g===document.scrollingElement&&(g=null));const F={...e.observerOptions,root:g};r=new IntersectionObserver(c,F)}function w(){r&&(r.disconnect(),i.value.forEach(({element:t})=>{t&&r.observe(t)}))}function S(){r&&(r.disconnect(),r=null)}y(()=>{if(e.firstItemActive&&i.value.length>0){const t=i.value[0];t&&(t.active=!0)}E(),w()}),T(()=>{S()}),Y(()=>i.value.length,()=>{m(()=>{w()})})}export{D as useScrollAnchors};
