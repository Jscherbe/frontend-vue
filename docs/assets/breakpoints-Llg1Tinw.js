import{r as d}from"./array-CBO3zkTJ.js";import{a7 as f,a8 as g,a9 as u,aa as p}from"./iframe-ULHYlDKO.js";import"./preload-helper-BJwshlQW.js";const v={iconClassClose:"css-icon css-icon--close",iconClassDragX:"css-icon css-icon--drag-x",iconClassDragBoth:"css-icon css-icon--drag-both",iconClassPrevious:"css-icon  css-icon--angle-left",iconClassNext:"css-icon  css-icon--angle-right",cssvarPrefix:""};let m={...v};function b(i){if(!m.hasOwnProperty(i)){console.warn(`Attempted to access non-existent setting: ${i}`);return}return m[i]}function k(i,e){return{toString(){const t=b(i);return e?e(t):t}}}function y(i,e){return`--${i}-${e}`}var x=Object.defineProperty,C=(i,e,t)=>e in i?x(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,l=(i,e,t)=>C(i,typeof e!="symbol"?e+"":e,t);const I=i=>y(i,"breakpoint"),o=class s{static _initializeGlobals(){s.globalsInitialized||!f()||(window.addEventListener(g("pageResized"),()=>{s.instances.forEach(e=>e.update())}),s.globalsInitialized=!0)}constructor(e){s._initializeGlobals(),Object.assign(this,s.defaults,e),this.active=null,this.previous=null,this.activeIndex=null,this.resizeDirection=null,this.previousIndex=null,this.breakpoints={},this.onChangeCallbacks=[],this.order.forEach(t=>this.breakpoints[t]=new P(t,this)),u(this,this),this.update(),s.instances.push(this)}onChange(e){this.onChangeCallbacks.push(e)}removeOnChange(e){d(this.onChangeCallbacks,e)}getBreakpointInPseudo(){return window.getComputedStyle(this.element,this.pseudoSelector).content.replace(/^"|"$/g,"")}getBreakpointInProperty(){return getComputedStyle(this.element).getPropertyValue(this.customProperty).trim()}getBreakpoint(){return this.valueFromPseudo?this.getBreakpointInPseudo():this.getBreakpointInProperty()}update(){const e=this.getBreakpoint();if(!e){p(this,"Unable to get current breakpoint, maybe order is incorrect? Breakpoint check skipped!");return}if(e===this.active)return;this.previous=this.active,this.previousIndex=this.activeIndex;const t=this.order.indexOf(e);this.active=e,this.activeIndex=t,this.order.forEach((n,r)=>{const a=this.breakpoints[n],c=this.activeIndex;a._setDirection("min",r<=c),a._setDirection("max",r>c),a._setDirection("only",r===c)}),this.previousIndex!==null&&(this.resizeDirection=this.previousIndex<t?"up":"down"),this.onChangeCallbacks.forEach(n=>n(this))}at(e){const t=this.breakpoints[e];return e||p(this,"Unable to find breakpoint for:",t),t}};l(o,"instances",[]),l(o,"globalsInitialized",!1),l(o,"defaults",{element:document?.documentElement,valueFromPseudo:!1,customProperty:"--breakpoint",customProperty:k("cssvarPrefix",I),pseudoSelector:":before",order:["none","small","medium","large"],debug:!1});let E=o;class h{constructor(e,t){this.direction=e,this.active=!1,this.on=[],this.off=[],this.breakpoint=t}change(e){this.active!==e&&(e?this._call(!0):this.active&&this._call(!1),this.active=e)}_call(e){(e?this.on:this.off).forEach(t=>t()),u(this.breakpoint._manager,`Handlers called (${e?"on":"off"}): ${this.direction}`)}getHandlers(e){return typeof e!="object"?{on:e}:e}add(e){const t=this.getHandlers(e);t.on&&this.on.push(t.on),t.off&&this.off.push(t.off),this.active&&t.on&&(t.on(),u(this.breakpoint._manager,`Handler called immediately: ${this.direction}`,t.on))}remove(e){const t=this.getHandlers(e);t.on&&d(this.on,t.on),t.off&&d(this.off,t.off)}}class P{constructor(e,t){this.directions={max:new h("max",this),min:new h("min",this),only:new h("only",this)},this._manager=t,this.name=e}_setDirection(e,t){this.directions[e].change(t)}max(e){this.directions.max.add(e)}min(e){this.directions.min.add(e)}only(e){this.directions.only.add(e)}remove(e,t){(t?[t]:["max","min","only"]).forEach(n=>{this.directions[n]&&this.directions[n].remove(e)})}log(...e){e.unshift(`Breakpoint (${this.name}):`),this._manager.log.apply(this._manager,e)}}export{E as BreakpointManager};
