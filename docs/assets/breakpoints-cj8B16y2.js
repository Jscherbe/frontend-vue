import{bg as o,bh as h,bi as p,bj as v}from"./iframe-CpwZzjQD.js";import"./preload-helper-BJwshlQW.js";const b={iconClassClose:"css-icon css-icon--close",iconClassDragX:"css-icon css-icon--drag-x",iconClassDragBoth:"css-icon css-icon--drag-both",iconClassPrevious:"css-icon  css-icon--angle-left",iconClassNext:"css-icon  css-icon--angle-right",cssvarPrefix:""};let m={...b};function k(s){if(!m.hasOwnProperty(s)){console.warn(`Attempted to access non-existent setting: ${s}`);return}return m[s]}function x(s,t){return{toString(){const e=k(s);return t?t(e):e}}}function y(s,t){return`--${s}-${t}`}const C=s=>y(s,"breakpoint");window.addEventListener(v("pageResized"),()=>{a.instances.forEach(s=>s.update())});class a{static instances=[];static defaults={element:document?.documentElement,valueFromPseudo:!1,customProperty:"--breakpoint",customProperty:x("cssvarPrefix",C),pseudoSelector:":before",order:["none","small","medium","large"],debug:!1};constructor(t){Object.assign(this,a.defaults,t),this.active=null,this.previous=null,this.activeIndex=null,this.resizeDirection=null,this.previousIndex=null,this.breakpoints={},this.onChangeCallbacks=[],this.order.forEach(e=>this.breakpoints[e]=new P(e,this)),o(this,this),this.update(),a.instances.push(this)}onChange(t){this.onChangeCallbacks.push(t)}removeOnChange(t){h(this.onChangeCallbacks,t)}getBreakpointInPseudo(){return window.getComputedStyle(this.element,this.pseudoSelector).content.replace(/^"|"$/g,"")}getBreakpointInProperty(){return getComputedStyle(this.element).getPropertyValue(this.customProperty).trim()}getBreakpoint(){return this.valueFromPseudo?this.getBreakpointInPseudo():this.getBreakpointInProperty()}update(){const t=this.getBreakpoint();if(!t){p(this,"Unable to get current breakpoint, maybe order is incorrect? Breakpoint check skipped!");return}if(t===this.active)return;this.previous=this.active,this.previousIndex=this.activeIndex;const e=this.order.indexOf(t);this.active=t,this.activeIndex=e;const r=this.at(this.active),n=i=>this.at(i),l=this.order.slice(e).map(n),f=this.order.slice(0,e).map(n),d=this.order.slice(0,e+1).map(n),g=this.order.slice(e+1).map(n),u=this.order.slice().map(n);u.splice(e,1),o(this,"max:",l.map(i=>i.name).join()),o(this,"min:",d.map(i=>i.name).join()),l.forEach(i=>i._setDirection("max",!0)),d.forEach(i=>i._setDirection("min",!0)),r._setDirection("only",!0),f.forEach(i=>i._setDirection("max",!1)),g.forEach(i=>i._setDirection("min",!1)),u.forEach(i=>i._setDirection("only",!1)),this.previousIndex!==null&&(this.resizeDirection=this.previousIndex<e?"up":"down"),this.onChangeCallbacks.forEach(i=>i(this))}at(t){const e=this.breakpoints[t];return t||p(this,"Unable to find breakpoint for:",e),e}}class c{constructor(t,e){this.direction=t,this.active=!1,this.on=[],this.off=[],this.breakpoint=e}change(t){this.active!==t&&(t?this._call(!0):this.active&&this._call(!1),this.active=t)}_call(t){(t?this.on:this.off).forEach(r=>r()),o(this.breakpoint._manager,`Handlers called (${t?"on":"off"}): ${this.direction}`)}getHandlers(t){return typeof t!="object"?{on:t}:t}add(t){const e=this.getHandlers(t);e.on&&this.on.push(e.on),e.off&&this.off.push(e.off),this.active&&e.on&&(e.on(),o(this.breakpoint._manager,`Handler called immediately: ${this.direction}`,e.on))}remove(t){const e=this.getHandlers(t);e.on&&h(this.on,e.on),e.off&&h(this.off,e.off)}}class P{constructor(t,e){this.directions={max:new c("max",this),min:new c("min",this),only:new c("only",this)},this._manager=e,this.name=t}_setDirection(t,e){this.directions[t].change(e)}max(t){this.directions.max.add(t)}min(t){this.directions.min.add(t)}only(t){this.directions.only.add(t)}remove(t,e){(e?[e]:["max","min","only"]).forEach(n=>n.remove(t))}log(...t){t.unshift(`Breakpoint (${this.name}):`),this._manager.log.apply(this._manager,t)}}export{a as BreakpointManager};
